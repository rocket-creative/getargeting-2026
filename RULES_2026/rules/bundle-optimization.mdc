# bundle-optimization.mdc
## Bundle Size Optimization & Analysis

### BUNDLE ANALYZER

**Tool**: `@next/bundle-analyzer`

**Installation**
```bash
npm install --save-dev @next/bundle-analyzer
```

**Configuration** (`next.config.ts`)
```typescript
// Conditionally apply bundle analyzer
let config: NextConfig = nextConfig;

if (process.env.ANALYZE === 'true') {
  const withBundleAnalyzer = require('@next/bundle-analyzer')({
    enabled: true,
  });
  config = withBundleAnalyzer(config);
}

export default config;
```

**Usage**
```bash
# Analyze bundle size
npm run analyze
```

This opens interactive reports showing:
- Bundle composition
- Chunk sizes
- Module dependencies
- Duplicate dependencies

**When to Run**
- Before major releases
- After adding large dependencies
- When bundle size budgets are exceeded
- Weekly during active development

### WEBPACK CODE SPLITTING

**Configuration** (`next.config.ts`)

```typescript
webpack: (config, { isServer }) => {
  if (!isServer) {
    config.optimization = {
      ...config.optimization,
      moduleIds: 'deterministic',
      runtimeChunk: 'single',
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          // GSAP vendor chunk
          gsap: {
            name: 'gsap',
            chunks: 'all',
            test: /[\\/]node_modules[\\/](gsap)[\\/]/,
            priority: 30,
          },
          // React vendor chunk
          react: {
            name: 'react',
            chunks: 'all',
            test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
            priority: 20,
          },
          // Other vendor chunk
          vendor: {
            name: 'vendor',
            chunks: 'all',
            test: /[\\/]node_modules[\\/]/,
            priority: 10,
          },
        },
      },
    };
  }
  return config;
}
```

**Benefits**
- Separate chunks for large libraries (GSAP, React)
- Better browser caching
- Parallel loading of chunks
- Deterministic module IDs for stable builds

**Note**: Webpack config only applies when using `--webpack` flag. Turbopack has built-in optimizations.

### DYNAMIC IMPORTS

**Pattern for Below-Fold Components**

```typescript
import dynamic from 'next/dynamic';

// Lazy load below-fold components
const BelowFoldComponent = dynamic(
  () => import('./components/BelowFoldComponent'),
  { ssr: true } // Keep SSR for SEO
);
```

**When to Use**
- Components below the fold
- Heavy components (charts, maps, editors)
- Route-based code splitting
- Components with large dependencies

**Example: Homepage Implementation**

```typescript
// Critical above-fold - loaded immediately
import HeroSection from './components/homepage/HeroSection';
import CoreServicesSection from './components/homepage/CoreServicesSection';

// Below-fold - lazy loaded
const TestimonialsSection = dynamic(
  () => import('./components/homepage/TestimonialsSection'),
  { ssr: true }
);
const FAQSection = dynamic(
  () => import('./components/homepage/FAQSection'),
  { ssr: true }
);
```

**SSR Consideration**
- Set `ssr: true` for SEO-critical components
- Set `ssr: false` for client-only components (charts, maps)

### PACKAGE IMPORT OPTIMIZATION

**Configuration** (`next.config.ts`)

```typescript
experimental: {
  optimizePackageImports: ['gsap', '@headlessui/react'],
}
```

**Benefits**
- Tree-shakes unused exports
- Reduces bundle size
- Faster builds

**Add packages that:**
- Export many modules
- Are commonly imported partially
- Have large unused exports

### BUNDLE SIZE BUDGETS

**Enforcement** (see performance.mdc for details)
- Initial bundle: < 150KB compressed
- Per route chunk: < 50KB compressed
- Total JS: < 500KB compressed

**Monitoring**
- Run `npm run analyze` before releases
- Check bundle sizes in CI/CD
- Set up alerts for budget violations

### TURBOPACK vs WEBPACK

**Next.js 16+ Default**: Turbopack

**Turbopack**
- Faster builds
- Built-in optimizations
- No custom webpack config needed
- Use: `npm run build` (default)

**Webpack**
- Custom optimization configs
- More control over splitting
- Use: `npm run build:webpack`

**Configuration**
```typescript
// Enable Turbopack (default in Next.js 16+)
turbopack: {},

// Webpack config (only applies with --webpack flag)
webpack: (config, { isServer }) => {
  // Custom optimizations
}
```

### BEST PRACTICES

**DO**
- Run bundle analyzer regularly
- Split large vendor libraries
- Use dynamic imports for below-fold content
- Monitor bundle sizes in CI/CD
- Optimize package imports

**DON'T**
- Import entire libraries when only using one function
- Bundle large dependencies in initial load
- Ignore bundle size budgets
- Skip bundle analysis before releases

### TROUBLESHOOTING

**Large Bundle Size**
1. Run `npm run analyze` to identify large modules
2. Check for duplicate dependencies
3. Use dynamic imports for heavy components
4. Consider code splitting at route level

**Slow Builds**
1. Check if using Turbopack (faster)
2. Review webpack config complexity
3. Consider reducing bundle analyzer frequency

**Cache Issues**
- Use deterministic module IDs
- Ensure proper cache headers
- Check for changing hashes in filenames
